use std::collections::{HashMap, HashSet};
use std::fs::File;
use std::io::Write;

use chrono::Local;
use colored::*;
use itertools::Itertools;
use tabled::{Table, Tabled, settings::Style};

use crate::cloud::CloudAssetFinding;
use crate::social::SocialIntelligenceSummary;

pub struct PrettyReportGenerator;

#[derive(Tabled)]
struct SubdomainRow {
    #[tabled(rename = "Subdomain")]
    subdomain: String,
    #[tabled(rename = "Status")]
    status: String,
    #[tabled(rename = "Server")]
    server: String,
    #[tabled(rename = "Ports")]
    ports: String,
    #[tabled(rename = "CORS")]
    cors: String,
    #[tabled(rename = "Risks")]
    risks: String,
}

impl PrettyReportGenerator {
    pub fn generate_markdown_report(
        domain: &str,
        subs: &HashSet<String>,
        header_map: &HashMap<String, (u16, Option<String>)>,
        open_ports_map: &HashMap<String, Vec<u16>>,
        cors_map: &HashMap<String, Vec<String>>,
        software_map: &HashMap<String, HashMap<String, String>>,
        takeover_map: &HashMap<String, Vec<String>>,
        _cloud_saas_map: &HashMap<String, Vec<String>>,
        cloud_asset_map: &HashMap<String, Vec<CloudAssetFinding>>,
        social_intel: Option<&SocialIntelligenceSummary>,
        output_dir: &str,
    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        let report_file = format!("{}/{}_REPORT.md", output_dir, domain);
        let mut f = File::create(&report_file)?;

        let timestamp = Local::now().format("%Y-%m-%d %H:%M:%S %Z");
        
        // Header
        writeln!(f, "# ğŸ” ShadowMap Security Report")?;
        writeln!(f)?;
        writeln!(f, "**Target Domain:** `{}`", domain)?;
        writeln!(f, "**Scan Date:** {}", timestamp)?;
        writeln!(f, "**Generated by:** ShadowMap v{}", env!("CARGO_PKG_VERSION"))?;
        writeln!(f)?;
        writeln!(f, "---")?;
        writeln!(f)?;

        // Executive Summary
        writeln!(f, "## ğŸ“Š Executive Summary")?;
        writeln!(f)?;
        
        let total_subs = subs.len();
        let cors_issues = cors_map.len();
        let takeover_risks = takeover_map.len();
        let cloud_assets = cloud_asset_map.len();
        
        let risk_level = if cors_issues > 0 || takeover_risks > 0 {
            "ğŸ”´ **HIGH**"
        } else if cloud_assets > 5 {
            "ğŸŸ¡ **MEDIUM**"
        } else {
            "ğŸŸ¢ **LOW**"
        };
        
        writeln!(f, "| Metric | Value |")?;
        writeln!(f, "|--------|-------|")?;
        writeln!(f, "| **Total Subdomains Discovered** | {} |", total_subs)?;
        writeln!(f, "| **Live Hosts** | {} |", total_subs)?;
        writeln!(f, "| **CORS Vulnerabilities** | {} |", cors_issues)?;
        writeln!(f, "| **Takeover Risks** | {} |", takeover_risks)?;
        writeln!(f, "| **Cloud Assets Flagged** | {} |", cloud_assets)?;
        writeln!(f, "| **Overall Risk Level** | {} |", risk_level)?;
        writeln!(f)?;

        // Critical Findings
        if cors_issues > 0 || takeover_risks > 0 {
            writeln!(f, "## ğŸš¨ Critical Security Findings")?;
            writeln!(f)?;

            if cors_issues > 0 {
                writeln!(f, "### âš ï¸ CORS Misconfigurations")?;
                writeln!(f)?;
                writeln!(f, "**Severity:** ğŸ”´ HIGH")?;
                writeln!(f, "**Impact:** Data theft, unauthorized API access")?;
                writeln!(f)?;
                
                for (sub, issues) in cors_map.iter().sorted_by_key(|(k, _)| k.as_str()) {
                    writeln!(f, "**Host:** `{}`", sub)?;
                    for issue in issues {
                        writeln!(f, "- âš ï¸ {}", issue)?;
                    }
                    writeln!(f)?;
                }
                
                writeln!(f, "**Recommended Fix:**")?;
                writeln!(f, "```nginx")?;
                writeln!(f, "# Remove wildcard CORS")?;
                writeln!(f, "add_header Access-Control-Allow-Origin \"https://yourdomain.com\" always;")?;
                writeln!(f, "# OR remove credentials if wildcard needed")?;
                writeln!(f, "# remove_header Access-Control-Allow-Credentials;")?;
                writeln!(f, "```")?;
                writeln!(f)?;
            }

            if takeover_risks > 0 {
                writeln!(f, "### ğŸ¯ Subdomain Takeover Risks")?;
                writeln!(f)?;
                for (sub, risks) in takeover_map.iter().sorted_by_key(|(k, _)| k.as_str()) {
                    writeln!(f, "**Subdomain:** `{}`", sub)?;
                    for risk in risks {
                        writeln!(f, "- ğŸ¯ {}", risk)?;
                    }
                    writeln!(f)?;
                }
            }
        }

        // All Discovered Subdomains
        writeln!(f, "## ğŸŒ Discovered Subdomains")?;
        writeln!(f)?;
        writeln!(f, "| # | Subdomain | Status | Server | Open Ports | Issues |")?;
        writeln!(f, "|---|-----------|--------|--------|------------|--------|")?;
        
        for (idx, sub) in subs.iter().sorted().enumerate() {
            let (status, server) = header_map.get(sub).cloned().unwrap_or((0, None));
            let status_icon = match status {
                200..=299 => "âœ…",
                300..=399 => "ğŸ”„",
                400..=499 => "âš ï¸",
                500..=599 => "ğŸ”´",
                _ => "â“",
            };
            
            let ports = open_ports_map.get(sub)
                .map(|v| v.iter().map(|p| p.to_string()).join(", "))
                .unwrap_or_else(|| "-".to_string());
            
            let issues_count = cors_map.get(sub).map(|v| v.len()).unwrap_or(0)
                + takeover_map.get(sub).map(|v| v.len()).unwrap_or(0);
            
            let issues_display = if issues_count > 0 {
                format!("ğŸš¨ {}", issues_count)
            } else {
                "âœ…".to_string()
            };
            
            writeln!(
                f,
                "| {} | `{}` | {} {} | {} | {} | {} |",
                idx + 1,
                sub,
                status_icon,
                status,
                server.unwrap_or_else(|| "-".to_string()),
                ports,
                issues_display
            )?;
        }
        writeln!(f)?;

        // Port Analysis
        writeln!(f, "## ğŸ”Œ Port Analysis")?;
        writeln!(f)?;
        let mut all_ports: HashSet<u16> = HashSet::new();
        for ports in open_ports_map.values() {
            all_ports.extend(ports);
        }
        
        writeln!(f, "**Unique Open Ports:** {}", all_ports.iter().sorted().map(|p| p.to_string()).join(", "))?;
        writeln!(f)?;
        
        for port in all_ports.iter().sorted() {
            let hosts_with_port: Vec<&String> = open_ports_map
                .iter()
                .filter(|(_, ports)| ports.contains(port))
                .map(|(host, _)| host)
                .sorted()
                .collect();
            
            let service = match *port {
                22 => "SSH",
                80 => "HTTP",
                443 => "HTTPS",
                3306 => "MySQL",
                5432 => "PostgreSQL",
                6379 => "Redis",
                8080 => "HTTP Alt",
                8443 => "HTTPS Alt",
                _ => "Unknown",
            };
            
            writeln!(f, "### Port {} ({})", port, service)?;
            writeln!(f, "**Hosts:** {} hosts", hosts_with_port.len())?;
            for host in hosts_with_port {
                writeln!(f, "- `{}`", host)?;
            }
            writeln!(f)?;
        }

        // Software Fingerprints
        if !software_map.is_empty() {
            writeln!(f, "## ğŸ” Software Fingerprints")?;
            writeln!(f)?;
            
            for (sub, fingerprints) in software_map.iter().sorted_by_key(|(k, _)| k.as_str()) {
                if !fingerprints.is_empty() {
                    writeln!(f, "**{}**", sub)?;
                    for (key, value) in fingerprints {
                        writeln!(f, "- **{}:** `{}`", key, value)?;
                    }
                    writeln!(f)?;
                }
            }
        }

        // Cloud Assets
        if !cloud_asset_map.is_empty() {
            writeln!(f, "## â˜ï¸ Cloud Infrastructure Analysis")?;
            writeln!(f)?;
            writeln!(f, "**Total Predicted Assets:** {}", cloud_asset_map.values().map(|v| v.len()).sum::<usize>())?;
            writeln!(f)?;
            
            let mut provider_counts: HashMap<String, usize> = HashMap::new();
            for assets in cloud_asset_map.values() {
                for asset in assets {
                    *provider_counts.entry(asset.provider.clone()).or_insert(0) += 1;
                }
            }
            
            writeln!(f, "### Provider Breakdown")?;
            writeln!(f)?;
            for (provider, count) in provider_counts.iter().sorted_by_key(|(k, _)| k.as_str()) {
                writeln!(f, "- **{}:** {} assets", provider, count)?;
            }
            writeln!(f)?;
        }

        // Social Intelligence
        if let Some(intel) = social_intel {
            writeln!(f, "## ğŸ¤– AI-Powered Threat Intelligence")?;
            writeln!(f)?;
            writeln!(f, "**Framework:** {}", intel.framework_name)?;
            writeln!(f, "**Version:** {}", intel.framework_version)?;
            writeln!(f)?;
            
            writeln!(f, "### Metrics")?;
            writeln!(f, "- **Total Signals:** {}", intel.metrics.total_signals)?;
            writeln!(f, "- **Correlated Assets:** {}", intel.metrics.correlated_assets)?;
            writeln!(f, "- **Average Confidence:** {:.0}%", intel.metrics.average_confidence * 100.0)?;
            writeln!(f)?;
            
            if !intel.signals.is_empty() {
                writeln!(f, "### Detected Threats")?;
                writeln!(f)?;
                for signal in &intel.signals {
                    writeln!(f, "#### {} - {}", signal.signal_id, signal.topic)?;
                    writeln!(f, "- **Severity:** {}", signal.severity.to_uppercase())?;
                    writeln!(f, "- **Confidence:** {:.0}%", signal.confidence * 100.0)?;
                    writeln!(f, "- **Cloud Vendors:** {}", signal.vendor_cloud.join(", "))?;
                    writeln!(f, "- **Services:** {}", signal.services.join(", "))?;
                    writeln!(f)?;
                }
            }
            
            if !intel.remediations.is_empty() {
                writeln!(f, "### ğŸ› ï¸ Remediation Plan")?;
                writeln!(f)?;
                for remediation in &intel.remediations {
                    writeln!(f, "#### {}", remediation.title)?;
                    writeln!(f, "**Severity:** {} | **Due:** {} days", remediation.severity.to_uppercase(), remediation.due_days)?;
                    writeln!(f)?;
                    writeln!(f, "**Steps:**")?;
                    for (i, step) in remediation.steps.iter().enumerate() {
                        writeln!(f, "{}. {}", i + 1, step)?;
                    }
                    writeln!(f)?;
                    writeln!(f, "**Rollback:**")?;
                    for step in &remediation.rollback {
                        writeln!(f, "- {}", step)?;
                    }
                    writeln!(f)?;
                }
            }
        }

        // Recommendations
        writeln!(f, "## ğŸ’¡ Recommendations")?;
        writeln!(f)?;
        writeln!(f, "### Immediate Actions (P0)")?;
        if cors_issues > 0 {
            writeln!(f, "1. âš ï¸ **Fix CORS misconfigurations** on {} host(s)", cors_issues)?;
        }
        if takeover_risks > 0 {
            writeln!(f, "2. ğŸ¯ **Investigate subdomain takeover risks** on {} subdomain(s)", takeover_risks)?;
        }
        if open_ports_map.values().any(|ports| ports.contains(&22)) {
            writeln!(f, "3. ğŸ” **Review SSH exposure** - Port 22 should not be publicly accessible")?;
        }
        writeln!(f)?;
        
        writeln!(f, "### Short-term Actions (P1)")?;
        writeln!(f, "1. ğŸ” **Validate all predicted cloud buckets** for public access")?;
        writeln!(f, "2. ğŸ›¡ï¸ **Implement Web Application Firewall (WAF)**")?;
        writeln!(f, "3. ğŸ“Š **Set up continuous monitoring** for new subdomains")?;
        writeln!(f)?;
        
        writeln!(f, "### Long-term Actions (P2)")?;
        writeln!(f, "1. ğŸ”’ **Enable DNSSEC** for domain integrity")?;
        writeln!(f, "2. ğŸ“‹ **Conduct regular penetration testing**")?;
        writeln!(f, "3. ğŸ“ **Security awareness training** for development teams")?;
        writeln!(f)?;

        // Footer
        writeln!(f, "---")?;
        writeln!(f)?;
        writeln!(f, "**Report generated by ShadowMap** â€¢ [https://shadowmap.io](https://shadowmap.io)")?;
        writeln!(f, "*For questions or support, contact your security team.*")?;

        Ok(())
    }

    pub fn print_terminal_summary(
        domain: &str,
        subs: &HashSet<String>,
        header_map: &HashMap<String, (u16, Option<String>)>,
        open_ports_map: &HashMap<String, Vec<u16>>,
        cors_map: &HashMap<String, Vec<String>>,
        takeover_map: &HashMap<String, Vec<String>>,
        cloud_asset_map: &HashMap<String, Vec<CloudAssetFinding>>,
        social_intel: Option<&SocialIntelligenceSummary>,
    ) {
        println!();
        println!("{}", "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•".bright_cyan());
        println!("{}", format!("  SCAN RESULTS: {}", domain).bright_white().bold());
        println!("{}", "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•".bright_cyan());
        println!();

        // Quick Stats
        println!("{}", "ğŸ“Š QUICK STATS".bright_yellow().bold());
        println!("{}", "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€".bright_black());
        println!("  {} Subdomains discovered", subs.len().to_string().bright_green().bold());
        println!("  {} Live hosts verified", subs.len().to_string().bright_green().bold());
        
        if cors_map.is_empty() {
            println!("  {} CORS vulnerabilities", "0".bright_green().bold());
        } else {
            println!("  {} CORS vulnerabilities {}", cors_map.len().to_string().bright_red().bold(), "âš ï¸");
        }
        
        if takeover_map.is_empty() {
            println!("  {} Takeover risks", "0".bright_green().bold());
        } else {
            println!("  {} Takeover risks {}", takeover_map.len().to_string().bright_yellow().bold(), "âš ï¸");
        }
        
        println!("  {} Cloud assets flagged", cloud_asset_map.len().to_string().bright_cyan().bold());
        println!();

        // Critical Findings
        if !cors_map.is_empty() || !takeover_map.is_empty() {
            println!("{}", "ğŸš¨ CRITICAL FINDINGS".bright_red().bold());
            println!("{}", "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€".bright_black());
            
            for (sub, issues) in cors_map.iter().sorted_by_key(|(k, _)| k.as_str()) {
                println!("  {} {}", "CORS:".bright_red().bold(), sub.bright_white());
                for issue in issues {
                    println!("    â€¢ {}", issue.bright_yellow());
                }
            }
            
            for (sub, risks) in takeover_map.iter().sorted_by_key(|(k, _)| k.as_str()) {
                println!("  {} {}", "TAKEOVER:".bright_yellow().bold(), sub.bright_white());
                for risk in risks {
                    println!("    â€¢ {}", risk);
                }
            }
            println!();
        }

        // Top Subdomains Table
        println!("{}", "ğŸŒ DISCOVERED SUBDOMAINS".bright_cyan().bold());
        println!("{}", "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€".bright_black());
        
        let mut rows: Vec<SubdomainRow> = Vec::new();
        for sub in subs.iter().sorted().take(10) {
            let (status, server) = header_map.get(sub).cloned().unwrap_or((0, None));
            let status_str = if status == 0 {
                "N/A".to_string()
            } else {
                format!("{}", status)
            };
            
            let ports = open_ports_map.get(sub)
                .map(|v| v.iter().take(4).map(|p| p.to_string()).join(","))
                .unwrap_or_else(|| "-".to_string());
            
            let cors_str = if cors_map.contains_key(sub) {
                "âš ï¸ YES".to_string()
            } else {
                "âœ“".to_string()
            };
            
            let risks = if takeover_map.contains_key(sub) {
                "âš ï¸".to_string()
            } else {
                "âœ“".to_string()
            };
            
            rows.push(SubdomainRow {
                subdomain: sub.clone(),
                status: status_str,
                server: server.unwrap_or_else(|| "-".to_string()),
                ports,
                cors: cors_str,
                risks,
            });
        }
        
        if !rows.is_empty() {
            let table = Table::new(&rows).with(Style::rounded()).to_string();
            println!("{}", table);
        }
        
        if subs.len() > 10 {
            println!();
            println!("  {} more subdomain(s) not shown...", (subs.len() - 10).to_string().bright_black());
        }
        println!();

        // Social Intelligence Summary
        if let Some(intel) = social_intel {
            if intel.metrics.total_signals > 0 {
                println!("{}", "ğŸ¤– AI THREAT INTELLIGENCE".bright_magenta().bold());
                println!("{}", "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€".bright_black());
                println!("  {} signal(s) detected", intel.metrics.total_signals.to_string().bright_yellow().bold());
                println!("  {} confidence", format!("{:.0}%", intel.metrics.average_confidence * 100.0).bright_green().bold());
                
                for signal in &intel.signals {
                    println!("  â€¢ {} - {}", signal.signal_id.bright_cyan(), signal.topic);
                    println!("    Severity: {} | Confidence: {:.0}%", 
                        signal.severity.to_uppercase().bright_red(),
                        signal.confidence * 100.0
                    );
                }
                println!();
            }
        }

        println!("{}", "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•".bright_cyan());
        println!();
    }
}
