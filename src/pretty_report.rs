use std::collections::{HashMap, HashSet};
use std::fs::File;
use std::io::Write;

use chrono::Local;
use colored::*;
use itertools::Itertools;
use tabled::{Table, Tabled, settings::Style};

use crate::cloud::CloudAssetFinding;
use crate::social::SocialIntelligenceSummary;

pub struct ReconSummary<'a> {
    pub domain: &'a str,
    pub subs: &'a HashSet<String>,
    pub header_map: &'a HashMap<String, (u16, Option<String>)>,
    pub open_ports_map: &'a HashMap<String, Vec<u16>>,
    pub cors_map: &'a HashMap<String, Vec<String>>,
    pub software_map: &'a HashMap<String, HashMap<String, String>>,
    pub takeover_map: &'a HashMap<String, Vec<String>>,
    #[allow(dead_code)]
    pub cloud_saas_map: &'a HashMap<String, Vec<String>>,
    pub cloud_asset_map: &'a HashMap<String, Vec<CloudAssetFinding>>,
    pub social_intel: Option<&'a SocialIntelligenceSummary>,
    pub output_dir: &'a str,
}

pub struct PrettyReportGenerator;

#[derive(Tabled)]
struct SubdomainRow {
    #[tabled(rename = "Subdomain")]
    subdomain: String,
    #[tabled(rename = "Status")]
    status: String,
    #[tabled(rename = "Server")]
    server: String,
    #[tabled(rename = "Ports")]
    ports: String,
    #[tabled(rename = "CORS")]
    cors: String,
    #[tabled(rename = "Risks")]
    risks: String,
}

impl PrettyReportGenerator {
    pub fn generate_markdown_report(
        summary: &ReconSummary,
    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        let report_file = format!("{}/{}_REPORT.md", summary.output_dir, summary.domain);
        let mut f = File::create(&report_file)?;

        let timestamp = Local::now().format("%Y-%m-%d %H:%M:%S %Z");
        
        // Header
        writeln!(f, "# ShadowMap Security Report")?;
        writeln!(f)?;
        writeln!(f, "**Target Domain:** `{}`", summary.domain)?;
        writeln!(f, "**Scan Date:** {}", timestamp)?;
        writeln!(f, "**Generated by:** ShadowMap v{}", env!("CARGO_PKG_VERSION"))?;
        writeln!(f)?;
        writeln!(f, "---")?;
        writeln!(f)?;

        // Executive Summary
        writeln!(f, "## Executive Summary")?;
        writeln!(f)?;
        
        let total_subs = summary.subs.len();
        let cors_issues = summary.cors_map.len();
        let takeover_risks = summary.takeover_map.len();
        let cloud_assets = summary.cloud_asset_map.len();
        
        let risk_level = if cors_issues > 0 || takeover_risks > 0 {
            "**HIGH**"
        } else if cloud_assets > 5 {
            "**MEDIUM**"
        } else {
            "**LOW**"
        };
        
        writeln!(f, "| Metric | Value |")?;
        writeln!(f, "|--------|-------|")?;
        writeln!(f, "| **Total Subdomains Discovered** | {} |", total_subs)?;
        writeln!(f, "| **Live Hosts** | {} |", total_subs)?;
        writeln!(f, "| **CORS Vulnerabilities** | {} |", cors_issues)?;
        writeln!(f, "| **Takeover Risks** | {} |", takeover_risks)?;
        writeln!(f, "| **Cloud Assets Flagged** | {} |", cloud_assets)?;
        writeln!(f, "| **Overall Risk Level** | {} |", risk_level)?;
        writeln!(f)?;

        // Critical Findings
        if cors_issues > 0 || takeover_risks > 0 {
            writeln!(f, "## Critical Security Findings")?;
            writeln!(f)?;

            if cors_issues > 0 {
                writeln!(f, "### CORS Misconfigurations")?;
                writeln!(f)?;
                writeln!(f, "**Severity:** HIGH")?;
                writeln!(f, "**Impact:** Data theft, unauthorized API access")?;
                writeln!(f)?;
                
                for (sub, issues) in summary.cors_map.iter().sorted_by_key(|(k, _)| k.as_str()) {
                    writeln!(f, "**Host:** `{}`", sub)?;
                    for issue in issues {
                        writeln!(f, "- {}", issue)?;
                    }
                    writeln!(f)?;
                }
                
                writeln!(f, "**Recommended Fix:**")?;
                writeln!(f, "```nginx")?;
                writeln!(f, "# Remove wildcard CORS")?;
                writeln!(f, "add_header Access-Control-Allow-Origin \"https://yourdomain.com\" always;")?;
                writeln!(f, "# OR remove credentials if wildcard needed")?;
                writeln!(f, "# remove_header Access-Control-Allow-Credentials;")?;
                writeln!(f, "```")?;
                writeln!(f)?;
            }

            if takeover_risks > 0 {
                writeln!(f, "### Subdomain Takeover Risks")?;
                writeln!(f)?;
                for (sub, risks) in summary.takeover_map.iter().sorted_by_key(|(k, _)| k.as_str()) {
                    writeln!(f, "**Subdomain:** `{}`", sub)?;
                    for risk in risks {
                        writeln!(f, "- {}", risk)?;
                    }
                    writeln!(f)?;
                }
            }
        }

        // All Discovered Subdomains
        writeln!(f, "## Discovered Subdomains")?;
        writeln!(f)?;
        writeln!(f, "| # | Subdomain | Status | Server | Open Ports | Issues |")?;
        writeln!(f, "|---|-----------|--------|--------|------------|--------|")?;
        
        for (idx, sub) in summary.subs.iter().sorted().enumerate() {
            let (status, server) = summary.header_map.get(sub).cloned().unwrap_or((0, None));
            let status_icon = match status {
                200..=299 => "OK",
                300..=399 => "REDIRECT",
                400..=499 => "CLIENT_ERR",
                500..=599 => "SERVER_ERR",
                _ => "UNKNOWN",
            };
            
            let ports = summary.open_ports_map.get(sub)
                .map(|v| v.iter().map(|p| p.to_string()).join(", "))
                .unwrap_or_else(|| "-".to_string());
            
            let issues_count = summary.cors_map.get(sub).map(|v| v.len()).unwrap_or(0)
                + summary.takeover_map.get(sub).map(|v| v.len()).unwrap_or(0);
            
            let issues_display = if issues_count > 0 {
                format!("ISSUES: {}", issues_count)
            } else {
                "OK".to_string()
            };
            
            writeln!(
                f,
                "| {} | `{}` | {} {} | {} | {} | {} |",
                idx + 1,
                sub,
                status_icon,
                status,
                server.unwrap_or_else(|| "-".to_string()),
                ports,
                issues_display
            )?;
        }
        writeln!(f)?;

        // Port Analysis
        writeln!(f, "## Port Analysis")?;
        writeln!(f)?;
        let mut all_ports: HashSet<u16> = HashSet::new();
        for ports in summary.open_ports_map.values() {
            all_ports.extend(ports);
        }
        
        writeln!(f, "**Unique Open Ports:** {}", all_ports.iter().sorted().map(|p| p.to_string()).join(", "))?;
        writeln!(f)?;
        
        for port in all_ports.iter().sorted() {
            let hosts_with_port: Vec<&String> = summary.open_ports_map
                .iter()
                .filter(|(_, ports)| ports.contains(port))
                .map(|(host, _)| host)
                .sorted()
                .collect();
            
            let service = match *port {
                22 => "SSH",
                80 => "HTTP",
                443 => "HTTPS",
                3306 => "MySQL",
                5432 => "PostgreSQL",
                6379 => "Redis",
                8080 => "HTTP Alt",
                8443 => "HTTPS Alt",
                _ => "Unknown",
            };
            
            writeln!(f, "### Port {} ({})", port, service)?;
            writeln!(f, "**Hosts:** {} hosts", hosts_with_port.len())?;
            for host in hosts_with_port {
                writeln!(f, "- `{}`", host)?;
            }
            writeln!(f)?;
        }

        // Software Fingerprints
        if !summary.software_map.is_empty() {
            writeln!(f, "## Software Fingerprints")?;
            writeln!(f)?;
            
            for (sub, fingerprints) in summary.software_map.iter().sorted_by_key(|(k, _)| k.as_str()) {
                if !fingerprints.is_empty() {
                    writeln!(f, "**{}**", sub)?;
                    for (key, value) in fingerprints {
                        writeln!(f, "- **{}:** `{}`", key, value)?;
                    }
                    writeln!(f)?;
                }
            }
        }

        // Cloud Assets
        if !summary.cloud_asset_map.is_empty() {
            writeln!(f, "## Cloud Infrastructure Analysis")?;
            writeln!(f)?;
            writeln!(f, "**Total Predicted Assets:** {}", summary.cloud_asset_map.values().map(|v| v.len()).sum::<usize>())?;
            writeln!(f)?;
            
            let mut provider_counts: HashMap<String, usize> = HashMap::new();
            for assets in summary.cloud_asset_map.values() {
                for asset in assets {
                    *provider_counts.entry(asset.provider.clone()).or_insert(0) += 1;
                }
            }
            
            writeln!(f, "### Provider Breakdown")?;
            writeln!(f)?;
            for (provider, count) in provider_counts.iter().sorted_by_key(|(k, _)| k.as_str()) {
                writeln!(f, "- **{}:** {} assets", provider, count)?;
            }
            writeln!(f)?;
        }

        // Social Intelligence
        if let Some(intel) = summary.social_intel {
            writeln!(f, "## AI-Powered Threat Intelligence")?;
            writeln!(f)?;
            writeln!(f, "**Framework:** {}", intel.framework_name)?;
            writeln!(f, "**Version:** {}", intel.framework_version)?;
            writeln!(f)?;
            
            writeln!(f, "### Metrics")?;
            writeln!(f, "- **Total Signals:** {}", intel.metrics.total_signals)?;
            writeln!(f, "- **Correlated Assets:** {}", intel.metrics.correlated_assets)?;
            writeln!(f, "- **Average Confidence:** {:.0}%", intel.metrics.average_confidence * 100.0)?;
            writeln!(f)?;
            
            if !intel.signals.is_empty() {
                writeln!(f, "### Detected Threats")?;
                writeln!(f)?;
                for signal in &intel.signals {
                    writeln!(f, "#### {} - {}", signal.signal_id, signal.topic)?;
                    writeln!(f, "- **Severity:** {}", signal.severity.to_uppercase())?;
                    writeln!(f, "- **Confidence:** {:.0}%", signal.confidence * 100.0)?;
                    writeln!(f, "- **Cloud Vendors:** {}", signal.vendor_cloud.join(", "))?;
                    writeln!(f, "- **Services:** {}", signal.services.join(", "))?;
                    writeln!(f)?;
                }
            }
            
            if !intel.remediations.is_empty() {
                writeln!(f, "### Remediation Plan")?;
                writeln!(f)?;
                for remediation in &intel.remediations {
                    writeln!(f, "#### {}", remediation.title)?;
                    writeln!(f, "**Severity:** {} | **Due:** {} days", remediation.severity.to_uppercase(), remediation.due_days)?;
                    writeln!(f)?;
                    writeln!(f, "**Steps:**")?;
                    for (i, step) in remediation.steps.iter().enumerate() {
                        writeln!(f, "{}. {}", i + 1, step)?;
                    }
                    writeln!(f)?;
                    writeln!(f, "**Rollback:**")?;
                    for step in &remediation.rollback {
                        writeln!(f, "- {}", step)?;
                    }
                    writeln!(f)?;
                }
            }
        }

        // Recommendations
        writeln!(f, "## Recommendations")?;
        writeln!(f)?;
        writeln!(f, "### Immediate Actions (P0)")?;
        if cors_issues > 0 {
            writeln!(f, "1. **Fix CORS misconfigurations** on {} host(s)", cors_issues)?;
        }
        if takeover_risks > 0 {
            writeln!(f, "2. **Investigate subdomain takeover risks** on {} subdomain(s)", takeover_risks)?;
        }
        if summary.open_ports_map.values().any(|ports| ports.contains(&22)) {
            writeln!(f, "3. **Review SSH exposure** - Port 22 should not be publicly accessible")?;
        }
        writeln!(f)?;
        
        writeln!(f, "### Short-term Actions (P1)")?;
        writeln!(f, "1. **Validate all predicted cloud buckets** for public access")?;
        writeln!(f, "2. **Implement Web Application Firewall (WAF)**")?;
        writeln!(f, "3. **Set up continuous monitoring** for new subdomains")?;
        writeln!(f)?;
        
        writeln!(f, "### Long-term Actions (P2)")?;
        writeln!(f, "1. **Enable DNSSEC** for domain integrity")?;
        writeln!(f, "2. **Conduct regular penetration testing**")?;
        writeln!(f, "3. **Security awareness training** for development teams")?;
        writeln!(f)?;

        // Footer
        writeln!(f, "---")?;
        writeln!(f)?;
        writeln!(f, "**Report generated by ShadowMap** • [https://shadowmap.io](https://shadowmap.io)")?;
        writeln!(f, "*For questions or support, contact your security team.*")?;

        Ok(())
    }

    pub fn print_terminal_summary(summary: &ReconSummary) {
        println!();
        println!("{}", "═══════════════════════════════════════════════════════════".bright_cyan());
        println!("{}", format!("  SCAN RESULTS: {}", summary.domain).bright_white().bold());
        println!("{}", "═══════════════════════════════════════════════════════════".bright_cyan());
        println!();

        // Quick Stats
        println!("{}", "QUICK STATS".bright_yellow().bold());
        println!("{}", "─────────────────────────────────────────────────────────".bright_black());
        println!("  {} Subdomains discovered", summary.subs.len().to_string().bright_green().bold());
        println!("  {} Live hosts verified", summary.subs.len().to_string().bright_green().bold());
        
        if summary.cors_map.is_empty() {
            println!("  {} CORS vulnerabilities", "0".bright_green().bold());
        } else {
            println!("  {} CORS vulnerabilities [WARNING]", summary.cors_map.len().to_string().bright_red().bold());
        }
        
        if summary.takeover_map.is_empty() {
            println!("  {} Takeover risks", "0".bright_green().bold());
        } else {
            println!("  {} Takeover risks [WARNING]", summary.takeover_map.len().to_string().bright_yellow().bold());
        }
        
        println!("  {} Cloud assets flagged", summary.cloud_asset_map.len().to_string().bright_cyan().bold());
        println!();

        // Critical Findings
        if !summary.cors_map.is_empty() || !summary.takeover_map.is_empty() {
            println!("{}", "CRITICAL FINDINGS".bright_red().bold());
            println!("{}", "─────────────────────────────────────────────────────────".bright_black());
            
            for (sub, issues) in summary.cors_map.iter().sorted_by_key(|(k, _)| k.as_str()) {
                println!("  {} {}", "CORS:".bright_red().bold(), sub.bright_white());
                for issue in issues {
                    println!("    • {}", issue.bright_yellow());
                }
            }
            
            for (sub, risks) in summary.takeover_map.iter().sorted_by_key(|(k, _)| k.as_str()) {
                println!("  {} {}", "TAKEOVER:".bright_yellow().bold(), sub.bright_white());
                for risk in risks {
                    println!("    • {}", risk);
                }
            }
            println!();
        }

        // Top Subdomains Table
        println!("{}", "DISCOVERED SUBDOMAINS".bright_cyan().bold());
        println!("{}", "─────────────────────────────────────────────────────────".bright_black());
        
        let mut rows: Vec<SubdomainRow> = Vec::new();
        for sub in summary.subs.iter().sorted().take(10) {
            let (status, server) = summary.header_map.get(sub).cloned().unwrap_or((0, None));
            let status_str = if status == 0 {
                "N/A".to_string()
            } else {
                format!("{}", status)
            };
            
            let ports = summary.open_ports_map.get(sub)
                .map(|v| v.iter().take(4).map(|p| p.to_string()).join(","))
                .unwrap_or_else(|| "-".to_string());
            
            let cors_str = if summary.cors_map.contains_key(sub) {
                "WARNING".to_string()
            } else {
                "OK".to_string()
            };
            
            let risks = if summary.takeover_map.contains_key(sub) {
                "WARNING".to_string()
            } else {
                "OK".to_string()
            };
            
            rows.push(SubdomainRow {
                subdomain: sub.clone(),
                status: status_str,
                server: server.unwrap_or_else(|| "-".to_string()),
                ports,
                cors: cors_str,
                risks,
            });
        }
        
        if !rows.is_empty() {
            let table = Table::new(&rows).with(Style::rounded()).to_string();
            println!("{}", table);
        }
        
        if summary.subs.len() > 10 {
            println!();
            println!("  {} more subdomain(s) not shown...", (summary.subs.len() - 10).to_string().bright_black());
        }
        println!();

        // Social Intelligence Summary
        if let Some(intel) = summary.social_intel {
            if intel.metrics.total_signals > 0 {
                println!("{}", "AI THREAT INTELLIGENCE".bright_magenta().bold());
                println!("{}", "─────────────────────────────────────────────────────────".bright_black());
                println!("  {} signal(s) detected", intel.metrics.total_signals.to_string().bright_yellow().bold());
                println!("  {} confidence", format!("{:.0}%", intel.metrics.average_confidence * 100.0).bright_green().bold());
                
                for signal in &intel.signals {
                    println!("  • {} - {}", signal.signal_id.bright_cyan(), signal.topic);
                    println!("    Severity: {} | Confidence: {:.0}%", 
                        signal.severity.to_uppercase().bright_red(),
                        signal.confidence * 100.0
                    );
                }
                println!();
            }
        }

        println!("{}", "═══════════════════════════════════════════════════════════".bright_cyan());
        println!();
    }
}
